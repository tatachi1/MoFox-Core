<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MoFox Bot - è®°å¿†å›¾å¯è§†åŒ–</title>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
            gap: 10px;
            padding: 10px;
        }

        .sidebar {
            width: 320px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .graph-container {
            flex: 1;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            overflow: hidden;
            position: relative;
        }

        #memory-graph {
            width: 100%;
            height: 100%;
        }

        .controls {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            padding: 15px 20px;
        }

        h1 {
            color: #333;
            font-size: 24px;
            margin-bottom: 10px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        h2 {
            color: #555;
            font-size: 16px;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .search-box {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .search-box input {
            flex: 1;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .search-box input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .stat-item {
            background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
        }

        .legend {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            font-size: 13px;
        }

        .legend-color {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .filter-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .filter-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .filter-item label {
            flex: 1;
            font-size: 13px;
            cursor: pointer;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #667eea;
            font-size: 18px;
            font-weight: 500;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .info-panel {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 12px;
            font-size: 13px;
            max-height: 200px;
            overflow-y: auto;
        }

        .info-panel h3 {
            font-size: 14px;
            color: #667eea;
            margin-bottom: 8px;
        }

        .info-panel p {
            margin: 4px 0;
            color: #555;
        }

        .control-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .control-buttons .btn {
            flex: 1;
            min-width: 120px;
        }

        /* æ–‡ä»¶é€‰æ‹©å™¨æ¨¡æ€æ¡† */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            position: relative;
            background: white;
            margin: 5% auto;
            padding: 30px;
            width: 80%;
            max-width: 700px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #667eea;
        }

        .modal-header h2 {
            margin: 0;
            color: #333;
        }

        .close-btn {
            font-size: 28px;
            font-weight: bold;
            color: #999;
            cursor: pointer;
            transition: color 0.3s;
        }

        .close-btn:hover {
            color: #333;
        }

        .file-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .file-item {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }

        .file-item:hover {
            background: #e9ecef;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .file-item.current {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
        }

        .file-item-name {
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }

        .file-item-info {
            font-size: 12px;
            color: #666;
            display: flex;
            justify-content: space-between;
        }

        .file-item-current {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            margin-left: 10px;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                max-height: 300px;
            }
            .modal-content {
                width: 95%;
                margin: 10% auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- ä¾§è¾¹æ  -->
        <div class="sidebar">
            <h1>ğŸ¦Š è®°å¿†å›¾å¯è§†åŒ–</h1>
            
            <!-- æ–‡ä»¶é€‰æ‹© -->
            <div>
                <h2>ğŸ“‚ æ•°æ®æ–‡ä»¶</h2>
                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                    <button class="btn" style="flex: 1;" onclick="showFileSelector()">é€‰æ‹©æ–‡ä»¶</button>
                    <button class="btn btn-secondary" style="flex: 1;" onclick="loadFileList()">åˆ·æ–°åˆ—è¡¨</button>
                </div>
                <div id="currentFileInfo" style="font-size: 12px; color: #666; padding: 8px; background: #f8f9fa; border-radius: 6px;">
                    <p>åŠ è½½ä¸­...</p>
                </div>
            </div>

            <!-- æœç´¢ -->
            <div>
                <h2>ğŸ” æœç´¢è®°å¿†</h2>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="è¾“å…¥å…³é”®è¯æœç´¢...">
                    <button class="btn" onclick="searchMemories()">æœç´¢</button>
                </div>
            </div>

            <!-- ç»Ÿè®¡ä¿¡æ¯ -->
            <div>
                <h2>ğŸ“Š ç»Ÿè®¡ä¿¡æ¯</h2>
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-value" id="statNodes">0</div>
                        <div class="stat-label">èŠ‚ç‚¹æ•°</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statEdges">0</div>
                        <div class="stat-label">è¾¹æ•°</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statMemories">0</div>
                        <div class="stat-label">è®°å¿†æ•°</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statDensity">0%</div>
                        <div class="stat-label">å›¾å¯†åº¦</div>
                    </div>
                </div>
            </div>

            <!-- èŠ‚ç‚¹ç±»å‹å›¾ä¾‹ -->
            <div>
                <h2>ğŸ¨ èŠ‚ç‚¹ç±»å‹</h2>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FF6B6B;"></div>
                        <span>ä¸»ä½“ (SUBJECT)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4ECDC4;"></div>
                        <span>ä¸»é¢˜ (TOPIC)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #45B7D1;"></div>
                        <span>å®¢ä½“ (OBJECT)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FFA07A;"></div>
                        <span>å±æ€§ (ATTRIBUTE)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #98D8C8;"></div>
                        <span>å€¼ (VALUE)</span>
                    </div>
                </div>
            </div>

            <!-- è¿‡æ»¤å™¨ -->
            <div>
                <h2>ğŸ”§ è¿‡æ»¤å™¨</h2>
                <div class="filter-group">
                    <div class="filter-item">
                        <input type="checkbox" id="filterSubject" checked onchange="applyFilters()">
                        <label for="filterSubject">æ˜¾ç¤ºä¸»ä½“èŠ‚ç‚¹</label>
                    </div>
                    <div class="filter-item">
                        <input type="checkbox" id="filterTopic" checked onchange="applyFilters()">
                        <label for="filterTopic">æ˜¾ç¤ºä¸»é¢˜èŠ‚ç‚¹</label>
                    </div>
                    <div class="filter-item">
                        <input type="checkbox" id="filterObject" checked onchange="applyFilters()">
                        <label for="filterObject">æ˜¾ç¤ºå®¢ä½“èŠ‚ç‚¹</label>
                    </div>
                    <div class="filter-item">
                        <input type="checkbox" id="filterAttribute" checked onchange="applyFilters()">
                        <label for="filterAttribute">æ˜¾ç¤ºå±æ€§èŠ‚ç‚¹</label>
                    </div>
                    <div class="filter-item">
                        <input type="checkbox" id="filterValue" checked onchange="applyFilters()">
                        <label for="filterValue">æ˜¾ç¤ºå€¼èŠ‚ç‚¹</label>
                    </div>
                </div>
            </div>

            <!-- é€‰ä¸­èŠ‚ç‚¹ä¿¡æ¯ -->
            <div>
                <h2>â„¹ï¸ èŠ‚ç‚¹ä¿¡æ¯</h2>
                <div class="info-panel" id="nodeInfo">
                    <p style="color: #999;">ç‚¹å‡»èŠ‚ç‚¹æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯</p>
                </div>
            </div>
        </div>

        <!-- ä¸»å†…å®¹åŒº -->
        <div class="main-content">
            <!-- æ§åˆ¶æŒ‰é’® -->
            <div class="controls">
                <div class="control-buttons">
                    <button class="btn" onclick="loadGraph()">ğŸ”„ åˆ·æ–°å›¾å½¢</button>
                    <button class="btn btn-secondary" onclick="fitNetwork()">ğŸ“ é€‚åº”çª—å£</button>
                    <button class="btn" onclick="exportGraph()">ğŸ’¾ å¯¼å‡ºæ•°æ®</button>
                </div>
            </div>

            <!-- å›¾å½¢æ˜¾ç¤ºåŒº -->
            <div class="graph-container">
                <div id="memory-graph"></div>
                <div class="loading" id="loading">
                    <div class="loading-spinner"></div>
                    <div>æ­£åœ¨åŠ è½½è®°å¿†å›¾...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- æ–‡ä»¶é€‰æ‹©æ¨¡æ€æ¡† -->
    <div id="fileModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>ğŸ“‚ é€‰æ‹©æ•°æ®æ–‡ä»¶</h2>
                <span class="close-btn" onclick="closeFileSelector()">&times;</span>
            </div>
            <div id="fileListContainer">
                <div style="text-align: center; padding: 20px;">
                    <div class="loading-spinner"></div>
                    <p>åŠ è½½æ–‡ä»¶åˆ—è¡¨...</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let network = null;
        let availableFiles = [];
        let graphData = {
            nodes: [],
            edges: [],
            memories: []
        };
        let originalData = null;

        // èŠ‚ç‚¹é¢œè‰²é…ç½®
        const nodeColors = {
            'SUBJECT': '#FF6B6B',
            'TOPIC': '#4ECDC4',
            'OBJECT': '#45B7D1',
            'ATTRIBUTE': '#FFA07A',
            'VALUE': '#98D8C8'
        };

        // åˆå§‹åŒ–å›¾å½¢
        function initNetwork() {
            const container = document.getElementById('memory-graph');
            
            const options = {
                nodes: {
                    shape: 'dot',
                    size: 20,
                    font: {
                        size: 14,
                        color: '#333',
                        face: 'Microsoft YaHei'
                    },
                    borderWidth: 2,
                    borderWidthSelected: 4,
                    shadow: true
                },
                edges: {
                    width: 2,
                    color: {
                        color: '#848484',
                        highlight: '#667eea',
                        hover: '#764ba2'
                    },
                    arrows: {
                        to: {
                            enabled: true,
                            scaleFactor: 0.5
                        }
                    },
                    smooth: {
                        enabled: true,
                        type: 'dynamic'
                    },
                    font: {
                        size: 11,
                        color: '#666',
                        face: 'Microsoft YaHei',
                        align: 'middle'
                    }
                },
                physics: {
                    enabled: true,
                    barnesHut: {
                        gravitationalConstant: -8000,
                        centralGravity: 0.3,
                        springLength: 150,
                        springConstant: 0.04,
                        damping: 0.09,
                        avoidOverlap: 0.1
                    },
                    stabilization: {
                        enabled: true,
                        iterations: 300,
                        updateInterval: 25,
                        onlyDynamicEdges: false,
                        fit: true
                    },
                    // ç¨³å®šåè‡ªåŠ¨åœæ­¢ç‰©ç†å¼•æ“
                    solver: 'barnesHut',
                    timestep: 0.5,
                    adaptiveTimestep: true
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    zoomView: true,
                    dragView: true
                }
            };

            const data = {
                nodes: new vis.DataSet([]),
                edges: new vis.DataSet([])
            };

            network = new vis.Network(container, data, options);

            // æ·»åŠ äº‹ä»¶ç›‘å¬
            network.on('click', function(params) {
                if (params.nodes.length > 0) {
                    const nodeId = params.nodes[0];
                    showNodeInfo(nodeId);
                    highlightConnectedNodes(nodeId);
                } else {
                    // ç‚¹å‡»ç©ºç™½å¤„ï¼Œæ¢å¤æ‰€æœ‰èŠ‚ç‚¹
                    resetNodeHighlight();
                }
            });

            // ç¨³å®šåŒ–å®Œæˆååœæ­¢ç‰©ç†å¼•æ“
            network.on('stabilizationIterationsDone', function() {
                console.log('åˆå§‹ç¨³å®šåŒ–å®Œæˆï¼Œåœæ­¢ç‰©ç†å¼•æ“');
                network.setOptions({ physics: { enabled: false } });
            });

            // æ·»åŠ ç¨³å®šåŒ–è¿›åº¦ç›‘å¬
            network.on('stabilizationProgress', function(params) {
                const progress = Math.round((params.iterations / params.total) * 100);
                if (progress % 10 === 0) { // æ¯10%æ‰“å°ä¸€æ¬¡
                    console.log(`ç¨³å®šåŒ–è¿›åº¦: ${progress}%`);
                }
            });
        }

        // åŠ è½½å›¾å½¢æ•°æ®
        async function loadGraph() {
            try {
                document.getElementById('loading').style.display = 'block';
                
                const response = await fetch('/api/graph/full');
                const result = await response.json();

                if (result.success) {
                    originalData = result.data;
                    updateGraph(result.data);
                    updateStats(result.data.stats);
                } else {
                    alert('åŠ è½½å¤±è´¥: ' + result.error);
                }
            } catch (error) {
                console.error('åŠ è½½å›¾å½¢å¤±è´¥:', error);
                alert('åŠ è½½å¤±è´¥: ' + error.message);
            } finally {
                document.getElementById('loading').style.display = 'none';
            }
        }

        // æ›´æ–°å›¾å½¢æ˜¾ç¤º
        function updateGraph(data) {
            graphData = data;

            // å¤„ç†èŠ‚ç‚¹æ•°æ®
            const nodes = data.nodes.map(node => ({
                id: node.id,
                label: node.label,
                title: node.title,
                group: node.group,
                color: nodeColors[node.group] || '#999',
                metadata: node.metadata
            }));

            // å¤„ç†è¾¹æ•°æ®
            const edges = data.edges.map(edge => ({
                id: edge.id,
                from: edge.from,
                to: edge.to,
                label: edge.label,
                title: edge.title,
                width: edge.importance * 3 + 1
            }));

            // æ›´æ–°ç½‘ç»œ
            network.setData({
                nodes: new vis.DataSet(nodes),
                edges: new vis.DataSet(edges)
            });

            // æ³¨æ„ï¼šsetData ä¼šè‡ªåŠ¨è§¦å‘ç‰©ç†å¼•æ“é‡æ–°å¸ƒå±€
            // stabilizationIterationsDone äº‹ä»¶ç›‘å¬å™¨ä¼šè‡ªåŠ¨åœæ­¢ç‰©ç†å¼•æ“
        }

        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        function updateStats(stats) {
            document.getElementById('statNodes').textContent = stats.total_nodes;
            document.getElementById('statEdges').textContent = stats.total_edges;
            document.getElementById('statMemories').textContent = stats.total_memories;
            
            const density = stats.total_nodes > 0 
                ? ((stats.total_edges / (stats.total_nodes * (stats.total_nodes - 1))) * 100).toFixed(2)
                : 0;
            document.getElementById('statDensity').textContent = density + '%';
        }

        // æ˜¾ç¤ºèŠ‚ç‚¹ä¿¡æ¯
        function showNodeInfo(nodeId) {
            const node = graphData.nodes.find(n => n.id === nodeId);
            if (!node) return;

            const infoPanel = document.getElementById('nodeInfo');
            infoPanel.innerHTML = `
                <h3>${node.label}</h3>
                <p><strong>ç±»å‹:</strong> ${node.type}</p>
                <p><strong>ID:</strong> ${node.id.substring(0, 8)}...</p>
                <p><strong>åˆ›å»ºæ—¶é—´:</strong> ${new Date(node.created_at).toLocaleString('zh-CN')}</p>
                ${node.metadata && Object.keys(node.metadata).length > 0 
                    ? `<p><strong>å…ƒæ•°æ®:</strong> ${JSON.stringify(node.metadata, null, 2)}</p>`
                    : ''}
            `;
        }

        // æœç´¢è®°å¿†
        async function searchMemories() {
            const query = document.getElementById('searchInput').value;
            if (!query) {
                alert('è¯·è¾“å…¥æœç´¢å…³é”®è¯');
                return;
            }

            try {
                const response = await fetch(`/api/search?q=${encodeURIComponent(query)}&limit=50`);
                const result = await response.json();

                if (result.success) {
                    highlightSearchResults(result.data.results);
                } else {
                    alert('æœç´¢å¤±è´¥: ' + result.error);
                }
            } catch (error) {
                console.error('æœç´¢å¤±è´¥:', error);
                alert('æœç´¢å¤±è´¥: ' + error.message);
            }
        }

        // é«˜äº®æœç´¢ç»“æœ
        function highlightSearchResults(results) {
            const memoryIds = results.map(r => r.id);
            const relatedNodeIds = new Set();

            // æ‰¾å‡ºç›¸å…³çš„èŠ‚ç‚¹
            graphData.memories.forEach(memory => {
                if (memoryIds.includes(memory.id)) {
                    // è¿™é‡Œéœ€è¦æ‰¾åˆ°è¯¥è®°å¿†ç›¸å…³çš„æ‰€æœ‰èŠ‚ç‚¹
                    // ç®€åŒ–å®ç°ï¼šé«˜äº®æ‰€æœ‰èŠ‚ç‚¹
                    graphData.nodes.forEach(node => relatedNodeIds.add(node.id));
                }
            });

            // é«˜äº®èŠ‚ç‚¹
            if (relatedNodeIds.size > 0) {
                network.selectNodes([...relatedNodeIds]);
                network.fit({
                    nodes: [...relatedNodeIds],
                    animation: true
                });
            } else {
                alert('æœªæ‰¾åˆ°ç›¸å…³èŠ‚ç‚¹');
            }
        }

        // é«˜äº®ä¸é€‰ä¸­èŠ‚ç‚¹è¿æ¥çš„èŠ‚ç‚¹ï¼ˆæœ€å¤š3è·³æ·±åº¦ï¼‰
        function highlightConnectedNodes(nodeId) {
            if (!network || !graphData) return;

            // ä½¿ç”¨ BFS æ¢ç´¢æœ€å¤š3è·³æ·±åº¦çš„è¿æ¥èŠ‚ç‚¹
            const MAX_DEPTH = 3;
            const connectedNodeIds = new Set();
            const connectedEdgeIds = new Set();
            const visited = new Set();
            const queue = [{ nodeId: nodeId, depth: 0 }];

            // æ„å»ºé‚»æ¥è¡¨ä»¥æé«˜æŸ¥è¯¢æ•ˆç‡
            const adjacencyMap = new Map();
            graphData.edges.forEach(edge => {
                if (!adjacencyMap.has(edge.from)) {
                    adjacencyMap.set(edge.from, []);
                }
                if (!adjacencyMap.has(edge.to)) {
                    adjacencyMap.set(edge.to, []);
                }
                adjacencyMap.get(edge.from).push({ nodeId: edge.to, edgeId: edge.id });
                adjacencyMap.get(edge.to).push({ nodeId: edge.from, edgeId: edge.id });
            });

            // BFS éå†ï¼Œé™åˆ¶æ·±åº¦ä¸º3è·³
            while (queue.length > 0) {
                const { nodeId: currentNode, depth } = queue.shift();
                
                if (visited.has(currentNode)) continue;
                visited.add(currentNode);
                connectedNodeIds.add(currentNode);

                // å¦‚æœå·²ç»è¾¾åˆ°æœ€å¤§æ·±åº¦ï¼Œä¸å†æ¢ç´¢æ›´æ·±çš„èŠ‚ç‚¹
                if (depth >= MAX_DEPTH) continue;

                // æ¢ç´¢ç›¸é‚»èŠ‚ç‚¹
                const neighbors = adjacencyMap.get(currentNode) || [];
                neighbors.forEach(({ nodeId: neighborId, edgeId }) => {
                    connectedEdgeIds.add(edgeId);
                    if (!visited.has(neighborId)) {
                        queue.push({ nodeId: neighborId, depth: depth + 1 });
                    }
                });
            }

            console.log(`é€‰ä¸­èŠ‚ç‚¹: ${nodeId}, è¿æ¥çš„èŠ‚ç‚¹æ•°: ${connectedNodeIds.size}, è¿æ¥çš„è¾¹æ•°: ${connectedEdgeIds.size} (æœ€å¤§æ·±åº¦: ${MAX_DEPTH})`);

            // æ›´æ–°æ‰€æœ‰èŠ‚ç‚¹çš„é€æ˜åº¦
            const allNodes = network.body.data.nodes;
            const allEdges = network.body.data.edges;
            const updates = [];

            allNodes.get().forEach(node => {
                if (connectedNodeIds.has(node.id)) {
                    // è¿æ¥çš„èŠ‚ç‚¹ä¿æŒæ­£å¸¸ï¼Œç”šè‡³å¯ä»¥åŠ å¼ºæ˜¾ç¤º
                    // è¢«é€‰ä¸­çš„èŠ‚ç‚¹ç‰¹åˆ«çªå‡º
                    const isSelected = node.id === nodeId;
                    updates.push({
                        id: node.id,
                        opacity: 1.0,
                        borderWidth: isSelected ? 5 : 3,
                        font: { 
                            color: isSelected ? '#667eea' : '#333', 
                            size: isSelected ? 16 : 14, 
                            bold: true 
                        }
                    });
                } else {
                    // æ— å…³èŠ‚ç‚¹å˜ä¸ºé«˜åº¦é€æ˜
                    const dimmedColor = hexToRgba(node.color, 0.08);
                    updates.push({
                        id: node.id,
                        color: {
                            background: dimmedColor,
                            border: dimmedColor,
                            highlight: { background: dimmedColor, border: dimmedColor }
                        },
                        opacity: 0.08,
                        font: { color: 'rgba(51, 51, 51, 0.08)', size: 14 }
                    });
                }
            });
            allNodes.update(updates);

            // æ›´æ–°æ‰€æœ‰è¾¹çš„é€æ˜åº¦
            const edgeUpdates = [];
            allEdges.get().forEach(edge => {
                if (connectedEdgeIds.has(edge.id)) {
                    // è¿æ¥çš„è¾¹åŠ å¼ºæ˜¾ç¤º
                    edgeUpdates.push({
                        id: edge.id,
                        color: { color: '#667eea', opacity: 1.0 },
                        width: 4,
                        font: { color: '#667eea', size: 12 }
                    });
                } else {
                    // æ— å…³è¾¹å˜ä¸ºé«˜åº¦é€æ˜
                    edgeUpdates.push({
                        id: edge.id,
                        color: { color: '#848484', opacity: 0.03 },
                        width: 1,
                        font: { color: 'rgba(102, 102, 102, 0.03)', size: 11 }
                    });
                }
            });
            allEdges.update(edgeUpdates);

            // å°†è§†å›¾èšç„¦åˆ°è¿æ¥çš„å­å›¾
            if (connectedNodeIds.size > 1 && connectedNodeIds.size < 100) {
                network.fit({
                    nodes: Array.from(connectedNodeIds),
                    animation: {
                        duration: 800,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            }
        }

        // é‡ç½®èŠ‚ç‚¹é«˜äº®çŠ¶æ€
        function resetNodeHighlight() {
            if (!network || !graphData) return;

            const allNodes = network.body.data.nodes;
            const allEdges = network.body.data.edges;

            // æ¢å¤æ‰€æœ‰èŠ‚ç‚¹ - é‡æ–°åº”ç”¨åŸå§‹é¢œè‰²
            const nodeUpdates = [];
            allNodes.get().forEach(node => {
                const originalColor = nodeColors[node.group] || '#999';
                nodeUpdates.push({
                    id: node.id,
                    color: originalColor,
                    opacity: 1.0,
                    borderWidth: 2,
                    font: { color: '#333', size: 14, bold: false }
                });
            });
            allNodes.update(nodeUpdates);

            // æ¢å¤æ‰€æœ‰è¾¹
            const edgeUpdates = [];
            allEdges.get().forEach(edge => {
                edgeUpdates.push({
                    id: edge.id,
                    color: { color: '#848484', opacity: 1.0 },
                    width: 2,
                    font: { color: '#666', size: 11 }
                });
            });
            allEdges.update(edgeUpdates);
        }

        // è¾…åŠ©å‡½æ•°ï¼šå°†åå…­è¿›åˆ¶é¢œè‰²è½¬æ¢ä¸º rgba
        function hexToRgba(hex, alpha) {
            // å¦‚æœå·²ç»æ˜¯ rgba æ ¼å¼ï¼Œç›´æ¥è¿”å›
            if (hex.startsWith('rgba')) return hex;
            
            // å¤„ç† # å¼€å¤´çš„åå…­è¿›åˆ¶
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // åº”ç”¨è¿‡æ»¤å™¨
        function applyFilters() {
            if (!originalData) return;

            const filters = {
                'SUBJECT': document.getElementById('filterSubject').checked,
                'TOPIC': document.getElementById('filterTopic').checked,
                'OBJECT': document.getElementById('filterObject').checked,
                'ATTRIBUTE': document.getElementById('filterAttribute').checked,
                'VALUE': document.getElementById('filterValue').checked
            };

            // è¿‡æ»¤èŠ‚ç‚¹
            const filteredNodes = originalData.nodes.filter(node => 
                filters[node.group]
            );
            const filteredNodeIds = new Set(filteredNodes.map(n => n.id));

            // è¿‡æ»¤è¾¹ï¼ˆåªä¿ç•™ä¸¤ç«¯èŠ‚ç‚¹éƒ½å­˜åœ¨çš„è¾¹ï¼‰
            const filteredEdges = originalData.edges.filter(edge =>
                filteredNodeIds.has(edge.from) && filteredNodeIds.has(edge.to)
            );

            // æ›´æ–°å›¾å½¢
            updateGraph({
                nodes: filteredNodes,
                edges: filteredEdges,
                memories: originalData.memories,
                stats: {
                    total_nodes: filteredNodes.length,
                    total_edges: filteredEdges.length,
                    total_memories: originalData.stats.total_memories
                }
            });

            // é‡ç½®é«˜äº®çŠ¶æ€
            resetNodeHighlight();

            // é‡æ–°å¯ç”¨ç‰©ç†å¼•æ“ä»¥é‡æ–°å¸ƒå±€ï¼Œé¿å…èŠ‚ç‚¹æ’ç‰ˆé”™ä¹±
            if (network) {
                network.setOptions({ physics: { enabled: true } });
                
                // è®¾ç½®è¶…æ—¶ä¿æŠ¤ï¼Œç¡®ä¿ç‰©ç†å¼•æ“æœ€ç»ˆä¼šåœæ­¢
                let stabilized = false;
                const stabilizationTimeout = setTimeout(() => {
                    if (!stabilized) {
                        console.log('ç‰©ç†å¼•æ“ç¨³å®šè¶…æ—¶ï¼Œå¼ºåˆ¶åœæ­¢');
                        network.setOptions({ physics: { enabled: false } });
                    }
                }, 5000); // 5ç§’è¶…æ—¶

                // ç­‰å¾…ç¨³å®šåå†ç¦ç”¨ç‰©ç†å¼•æ“
                network.once('stabilizationIterationsDone', function() {
                    stabilized = true;
                    clearTimeout(stabilizationTimeout);
                    network.setOptions({ physics: { enabled: false } });
                    console.log('ç‰©ç†å¼•æ“å·²ç¨³å®šå¹¶åœæ­¢');
                });
            }
        }

        // é€‚åº”çª—å£
        function fitNetwork() {
            if (network) {
                network.fit({
                    animation: {
                        duration: 1000,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            }
        }

        // å¯¼å‡ºå›¾å½¢æ•°æ®
        function exportGraph() {
            const dataStr = JSON.stringify(graphData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `memory_graph_${new Date().getTime()}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        // æ–‡ä»¶é€‰æ‹©åŠŸèƒ½
        async function loadFileList() {
            try {
                const response = await fetch('/api/files');
                const result = await response.json();

                if (result.success) {
                    availableFiles = result.files;
                    updateCurrentFileInfo(result.current_file, result.files);
                    return result.files;
                } else {
                    console.error('åŠ è½½æ–‡ä»¶åˆ—è¡¨å¤±è´¥:', result.error);
                    return [];
                }
            } catch (error) {
                console.error('åŠ è½½æ–‡ä»¶åˆ—è¡¨å¤±è´¥:', error);
                return [];
            }
        }

        function updateCurrentFileInfo(currentFile, files) {
            const infoDiv = document.getElementById('currentFileInfo');
            
            if (!currentFile || files.length === 0) {
                infoDiv.innerHTML = '<p style="color: #e74c3c;">âŒ æœªæ‰¾åˆ°æ•°æ®æ–‡ä»¶</p>';
                return;
            }

            const currentFileObj = files.find(f => f.path === currentFile);
            if (currentFileObj) {
                infoDiv.innerHTML = `
                    <div style="margin-bottom: 5px;"><strong>ğŸ“„ ${currentFileObj.name}</strong></div>
                    <div style="display: flex; justify-content: space-between;">
                        <span>å¤§å°: ${currentFileObj.size_kb} KB</span>
                        <span>ä¿®æ”¹: ${currentFileObj.modified_readable.split(' ')[0]}</span>
                    </div>
                `;
            }
        }

        async function showFileSelector() {
            const modal = document.getElementById('fileModal');
            const container = document.getElementById('fileListContainer');
            
            modal.style.display = 'block';
            container.innerHTML = `
                <div style="text-align: center; padding: 20px;">
                    <div class="loading-spinner"></div>
                    <p>åŠ è½½æ–‡ä»¶åˆ—è¡¨...</p>
                </div>
            `;

            const files = await loadFileList();

            if (files.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #999;">
                        <p style="font-size: 48px; margin-bottom: 10px;">ğŸ“­</p>
                        <p>æœªæ‰¾åˆ°ä»»ä½•æ•°æ®æ–‡ä»¶</p>
                        <p style="font-size: 12px; margin-top: 10px;">è¯·å…ˆè¿è¡ŒBotç”Ÿæˆè®°å¿†æ•°æ®</p>
                    </div>
                `;
                return;
            }

            let html = '<div class="file-list">';
            files.forEach(file => {
                const currentBadge = file.is_current ? '<span class="file-item-current">å½“å‰</span>' : '';
                html += `
                    <div class="file-item ${file.is_current ? 'current' : ''}" onclick="selectFile('${file.path.replace(/\\/g, '\\\\')}')">
                        <div class="file-item-name">ğŸ“„ ${file.name}${currentBadge}</div>
                        <div class="file-item-info">
                            <span>å¤§å°: ${file.size_kb} KB</span>
                            <span>${file.modified_readable}</span>
                        </div>
                    </div>
                `;
            });
            html += '</div>';

            container.innerHTML = html;
        }

        function closeFileSelector() {
            document.getElementById('fileModal').style.display = 'none';
        }

        async function selectFile(filePath) {
            try {
                document.getElementById('loading').style.display = 'block';
                closeFileSelector();

                const response = await fetch('/api/select_file', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ file_path: filePath })
                });

                const result = await response.json();

                if (result.success) {
                    // é‡æ–°åŠ è½½å›¾å½¢
                    await loadGraph();
                    await loadFileList();
                    alert('âœ… ' + result.message);
                } else {
                    alert('âŒ åˆ‡æ¢æ–‡ä»¶å¤±è´¥: ' + result.error);
                }
            } catch (error) {
                console.error('åˆ‡æ¢æ–‡ä»¶å¤±è´¥:', error);
                alert('âŒ åˆ‡æ¢æ–‡ä»¶å¤±è´¥: ' + error.message);
            } finally {
                document.getElementById('loading').style.display = 'none';
            }
        }

        // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
        window.onclick = function(event) {
            const modal = document.getElementById('fileModal');
            if (event.target == modal) {
                closeFileSelector();
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', function() {
            initNetwork();
            loadGraph();
            loadFileList();
        });
    </script>
</body>
</html>
